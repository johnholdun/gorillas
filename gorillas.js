// Generated by CoffeeScript 1.7.1
(function() {
  var banana, canvases, colors, contextIndex, contexts, craters, deg2rad, draw, drawCircle, drawSprite, guessShot, init, isSky, isWind, leftGorilla, rad2deg, readBuildings, readCity, readWind, rightGorilla, sprites, stage, startRound, sun;

  canvases = [];

  contexts = [];

  contextIndex = 0;

  colors = {
    sky: [0, 0, 173],
    wind: [255, 0, 0],
    gorilla: [255, 170, 82]
  };

  sprites = {};

  stage = {};

  isWind = function(color) {
    return color[0] >= 200 && color[1] < 50 && color[2] < 50;
  };

  isSky = function(color) {
    return color[0] < 50 && color[1] < 50 && color[2] >= 140;
  };

  drawSprite = function(context, sprite, xOffset, yOffset) {
    return context.drawImage(sprite, xOffset, yOffset, sprite.width, sprite.height);
  };

  drawCircle = function(context, cx, cy, radius, color) {
    var data, height, width, x, y;
    if (!(radius > 0)) {
      return;
    }
    cx = Math.round(cx);
    cy = Math.round(cy);
    width = radius * 2;
    height = radius * 2;
    x = cx - radius;
    y = cy - radius;
    data = context.getImageData(x, y, width, height);
    _.each(_.range(0, width), function(px) {
      return _.each(_.range(0, height), function(py) {
        var pixelOffset;
        if (Math.sqrt(Math.pow(radius - px, 2) + Math.pow(radius - py, 2)) <= radius) {
          pixelOffset = (py * width + px) * 4;
          data.data[pixelOffset] = color[0];
          data.data[pixelOffset + 1] = color[1];
          data.data[pixelOffset + 2] = color[2];
          return data.data[pixelOffset + 3] = 255;
        }
      });
    });
    return context.putImageData(data, x, y);
  };

  leftGorilla = {
    side: 0,
    spriteNames: ["gorilla", "gorilla-left", "gorilla-right"],
    reset: function() {
      this.throwFrame = null;
      this.celebrating = false;
      this.celebrateFrame = null;
      this.dead = false;
      return this;
    },
    place: function(building) {
      var sprite;
      sprite = sprites[this.spriteNames[0]];
      this.width = sprite.width;
      this.height = sprite.height;
      this.x = building.left + Math.round((building.width - this.width) / 2);
      this.y = building.bottom - building.height - this.height + 1;
      this.left = this.x;
      this.right = this.x + this.width;
      this.top = this.y;
      return this.bottom = this.y + this.height;
    },
    draw: function(context, frame) {
      var building, sprite, spriteFrame;
      building = stage.buildings[this.buildingIndex];
      sprite = sprites.gorilla;
      if (this.throwFrame && frame - this.throwFrame < 5) {
        sprite = sprites[["gorilla-left", "gorilla-right"][this.side]];
      }
      if (this.celebrating && frame - this.celebrateFrame < 100) {
        spriteFrame = ["gorilla-right", "gorilla-left"][Math.floor((frame - this.celebrateFrame) / 25) % 2];
        sprite = sprites[spriteFrame];
      } else {
        this.celebrating = false;
      }
      return drawSprite(context, sprite, this.x, this.y);
    },
    "throw": function(frame, angle, velocity) {
      this.throwFrame = frame - 1;
      return banana.shoot(frame, this.side === 1 ? 180 - angle : angle, velocity, this.x + (this.width - sprites["banana-up"].width) * this.side, this.y - 15);
    },
    celebrate: function(frame) {
      this.celebrating = true;
      return this.celebrateFrame = frame;
    }
  };

  rightGorilla = _.extend({}, leftGorilla, {
    side: 1
  });

  craters = {
    init: function() {
      this.canvas = document.createElement("canvas");
      this.canvas.setAttribute("width", sprites.city.width);
      this.canvas.setAttribute("height", sprites.city.height);
      this.context = this.canvas.getContext("2d");
      return this.members = [];
    },
    add: function(frame, x, y, radius) {
      var crater;
      crater = {
        frame: frame,
        x: x,
        y: y,
        radius: radius
      };
      drawCircle(this.context, x, y, radius, colors.sky);
      return this.members.push(crater);
    },
    collide: function(x, y, width, height) {
      var pixelParts, region, result;
      region = this.context.getImageData(x, y, width, height).data;
      pixelParts = region.length / (width * height);
      result = _.find(_.range(0, width * height), function(pixel) {
        var color;
        color = [region[pixel * pixelParts], region[pixel * pixelParts + 1], region[pixel * pixelParts + 2]];
        return isSky(color);
      });
      return _.isNumber(result);
    },
    exploding: function(frame) {
      var pause;
      pause = 10;
      return _.find(this.members, function(crater) {
        return crater.frame + crater.radius + pause > frame;
      });
    },
    draw: function(context, frame) {
      var exploder;
      context.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height);
      exploder = this.exploding(frame);
      if (exploder) {
        return drawCircle(context, exploder.x, exploder.y, exploder.radius - (frame - exploder.frame), [255, 0, 0]);
      }
    }
  };

  banana = {
    spriteNames: ["banana-down", "banana-left", "banana-up", "banana-right"],
    draw: function(context, frame) {
      var bottom, buildingCollide, left, playerCollide, right, sprite, sunCollide, t, top;
      if (this.present) {
        t = (frame - this.frameOffset) / 20;
        this.x = this.origin.x + Math.round(this.velocity.x * t);
        this.y = this.origin.y - Math.round((this.velocity.y * t) + (0.5 * -9.8 * Math.pow(t, 2)));
        if (this.x < 0 || this.x > context.canvas.width || this.y > context.canvas.height) {
          this.present = false;
        } else {
          left = this.x;
          right = this.x + this.width;
          top = this.y;
          bottom = this.y + this.height;
          sunCollide = bottom > sun.top && top < sun.bottom && right > sun.left && left < sun.right;
          if (sunCollide) {
            sun.state = "shocked";
          }
          playerCollide = (frame - this.frameOffset > 10) && _.find([leftGorilla, rightGorilla], function(gorilla) {
            return bottom > gorilla.top && top < gorilla.bottom && right > gorilla.left && left < gorilla.right;
          });
          if (playerCollide) {
            [leftGorilla, rightGorilla][playerCollide.side].dead = true;
            [leftGorilla, rightGorilla][1 - playerCollide.side].celebrate(frame);
            craters.add(frame, this.x, this.y, 30);
            this.present = false;
          } else {
            buildingCollide = _.find(stage.buildings, function(building) {
              var bBottom, bLeft, bRight, bTop;
              bLeft = building.left;
              bRight = building.left + building.width;
              bBottom = building.bottom;
              bTop = building.bottom - building.height;
              return bottom > bTop && top < bBottom && right > bLeft && left < bRight;
            });
            if (buildingCollide && !craters.collide(this.x, this.y, this.width, this.height)) {
              craters.add(frame, this.x, this.y, 12);
              this.present = false;
            } else {
              sprite = sprites[this.spriteNames[Math.floor((frame - this.frameOffset) / 3) % this.spriteNames.length]];
            }
          }
        }
        if (this.present) {
          return drawSprite(context, sprite, this.x, this.y);
        }
      }
    },
    shoot: function(frame, angle, velocity, x, y) {
      this.width = sprites[this.spriteNames[0]].width;
      this.height = sprites[this.spriteNames[0]].height;
      this.velocity = {
        x: Math.cos(deg2rad(angle)) * velocity,
        y: Math.sin(deg2rad(angle)) * velocity
      };
      this.frameOffset = frame;
      this.origin = {
        x: x,
        y: y
      };
      return this.present = true;
    }
  };

  sun = {
    spriteNames: ["sun", "sun-shocked"],
    place: function(x, y) {
      var sprite;
      this.x = x;
      this.y = y;
      sprite = sprites[this.spriteNames[0]];
      this.width = sprite.width;
      this.height = sprite.height;
      this.left = this.x;
      this.right = this.x + this.width;
      this.top = this.y;
      return this.bottom = this.y + this.height;
    },
    draw: function(context, frame) {
      var sprite;
      sprite = sprites[this.spriteNames[this.state === "shocked" ? 1 : 0]];
      return drawSprite(context, sprite, this.x, this.y);
    }
  };

  draw = function(frame) {
    var canvas, context, present, shot;
    context = contexts[contextIndex];
    canvas = context.canvas;
    canvas.className = "buffer";
    drawSprite(context, sprites.city, 0, 0);
    if (frame > 0 && (leftGorilla.dead && !rightGorilla.celebrating) || (rightGorilla.dead && !leftGorilla.celebrating)) {
      startRound(stage.round + 1);
    } else {
      if (!(banana.present || craters.exploding(frame) || leftGorilla.celebrating || rightGorilla.celebrating)) {
        sun.state = "relaxed";
        stage.turnCount++;
        stage.turn = (stage.turn + 1) % 2;
        shot = guessShot(stage.turn, context);
        [leftGorilla, rightGorilla][stage.turn]["throw"](frame, shot.angle, shot.velocity);
      }
    }
    leftGorilla.draw(context, frame);
    rightGorilla.draw(context, frame);
    craters.draw(context, frame);
    banana.draw(context, frame);
    sun.draw(context, frame);
    present = document.querySelector("canvas.present");
    canvas.className = "present";
    if (present) {
      present.className = "buffer";
    }
    contextIndex = (contextIndex + 1) % 2;
    return frame;
  };

  readCity = function() {
    var canvas, cityData, context, image, imageData, pixelParts, pixels;
    image = sprites.city;
    canvas = document.createElement("canvas");
    canvas.setAttribute("width", image.width);
    canvas.setAttribute("height", image.height);
    context = canvas.getContext("2d");
    context.drawImage(image, 0, 0);
    imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    cityData = imageData.data;
    pixelParts = imageData.data.length / (imageData.width * imageData.height);
    pixels = new Array(cityData.length / pixelParts / imageData.width);
    _.each(_.range(0, canvas.height), function(y) {
      var row;
      row = new Array(canvas.width);
      _.each(_.range(0, canvas.width), function(x) {
        var pixelIndex;
        pixelIndex = (y * canvas.width + x) * pixelParts;
        return row[x] = [cityData[pixelIndex], cityData[pixelIndex + 1], cityData[pixelIndex + 2]];
      });
      return pixels[y] = row;
    });
    return {
      width: imageData.width,
      height: imageData.height,
      pixels: pixels
    };
  };

  readWind = function(city) {
    var wind, windDir, windVal;
    wind = {
      x: {},
      y: {}
    };
    _.each(_.range(0, city.height), function(y) {
      return _.each(_.range(0, city.width), function(x) {
        if (isWind(city.pixels[y][x])) {
          wind.y[y] || (wind.y[y] = 0);
          wind.y[y]++;
          wind.x[x] || (wind.x[x] = 0);
          return wind.x[x]++;
        }
      });
    });
    windVal = ((_.max(_.values(wind.y))) - 1) / 3;
    windDir = _.first(_.last(_.sortBy(_.pairs(wind.x), 1)));
    windDir = windDir > city.width / 2 ? 1 : -1;
    windVal *= windDir;
    windVal /= 10;
    return windVal;
  };

  readBuildings = function(city) {
    var bottomBuilding, building, buildings, inBuilding, x;
    buildings = [];
    x = 10;
    inBuilding = false;
    bottomBuilding = 0;
    _.every(_.range(0, city.height), function(y) {
      if (isSky(city.pixels[y][x])) {
        if (inBuilding) {
          bottomBuilding = y - 1;
          return false;
        }
      } else {
        inBuilding = true;
      }
      return true;
    });
    inBuilding = false;
    building = false;
    _.each(_.range(0, city.width), function(x) {
      if (isSky(city.pixels[bottomBuilding][x])) {
        if (building) {
          building.width = x - building.left;
          buildings.push(building);
          return building = false;
        }
      } else if (!building) {
        return building = {
          left: x,
          bottom: bottomBuilding
        };
      }
    });
    _.each(buildings, function(building) {
      return _.every(_.range(bottomBuilding, 0, -1), function(y) {
        if (isSky(city.pixels[y][building.left])) {
          building.height = bottomBuilding - y;
          return false;
        }
        return true;
      });
    });
    return buildings;
  };

  startRound = function(round, cityId) {
    var cityData, frame;
    sprites.city = cityId ? sprites["city-" + cityId] : _.sample(_.filter(sprites, function(sprite, id) {
      return id.match(/^city-/) && (!sprites.city || id !== sprites.city.id);
    }));
    if (stage && stage.interval) {
      clearInterval(stage.interval);
    }
    cityData = readCity();
    stage = {
      wind: readWind(cityData),
      buildings: readBuildings(cityData),
      turn: stage.turn || -1,
      turnCount: -1,
      round: round
    };
    craters.init();
    leftGorilla.reset().place(stage.buildings[_.random(1, 2)]);
    rightGorilla.reset().place(stage.buildings[stage.buildings.length - 1 - _.random(1, 2)]);
    sun.state = "relaxed";
    sun.place(300, 10);
    frame = 0;
    window.next = function() {
      return {
        wtf: "Wtf"
      };
    };
    if (location.search.match("mode=manual")) {
      return window.next = function() {
        draw(frame++);
        return stage;
      };
    } else {
      return stage.interval = setInterval(function() {
        return draw(frame++);
      }, 1000 / 30);
    }
  };

  guessShot = function(turn, context) {
    var angle, delta, destination, origin, tossee, tosser, velocity;
    tosser = [leftGorilla, rightGorilla][turn];
    tossee = [leftGorilla, rightGorilla][1 - turn];
    origin = {
      x: turn ? tosser.right : tosser.left,
      y: tosser.top
    };
    destination = {
      x: Math.round(tossee.left + tossee.width / 2),
      y: Math.round(tossee.top + tossee.height / 2)
    };
    delta = {
      x: Math.abs(destination.x - origin.x),
      y: destination.y - origin.y
    };
    velocity = {};
    angle = 50 + _.random(0, 20);
    velocity = Math.sqrt(delta.x * 9.8 / Math.sin(2 * deg2rad(angle)));
    velocity = velocity - 10 + _.random(0, 20);
    velocity -= stage.wind * _.random(0.4, 0.7, 0.1);
    return {
      angle: angle,
      velocity: velocity
    };
  };

  deg2rad = function(deg) {
    return deg / 180 * Math.PI;
  };

  rad2deg = function(rad) {
    return rad * 180 / Math.PI;
  };

  window.init = init = init = function() {
    var cityId, img;
    if (window.initialized) {
      return;
    }
    window.initialized = true;
    canvases = [document.getElementById("stage-1"), document.getElementById("stage-2")];
    contexts = _.map(canvases, function(canvas) {
      return canvas.getContext("2d");
    });
    _.each(document.querySelectorAll("img[id^='sprite-']"), function(img) {
      return sprites[img.getAttribute("id").replace(/^sprite-/, "")] = img;
    });
    cityId = location.search.match(/cityId=([0-9]+)/);
    if (cityId) {
      cityId = cityId[1];
      img = document.createElement("img");
      img.setAttribute("src", "cities/" + cityId + ".png");
      document.body.appendChild(img);
      sprites["city-" + cityId] = img;
      return img.addEventListener("load", function() {
        return _.defer(function() {
          return startRound(0, cityId);
        });
      });
    } else {
      return startRound(0);
    }
  };

  addEventListener("load", init);

}).call(this);
